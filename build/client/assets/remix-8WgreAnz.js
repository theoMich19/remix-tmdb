import{u as p}from"./components-BiZKUSio.js";let b=new Map;const k=r=>{const o=[],s=r.split(".");for(let e=0;e<s.length;e++)if(s[e].startsWith("[")){let i=s[e].substring(1),c=e+1;for(;!s[c].endsWith("]");)i+=`.${s[c]}`,c++;i+=`.${s[c].slice(0,-1)}`,o.push(i),e=c}else o.push(s[e]);return o};function m(r,o){Array.from(b.values());for(const e of Object.keys(o)){const i=k(e);s(r,i,o[e])}return r;function s(e,i,c,u=0){const n=i[u];if(u<i.length-1){s(e[n],i,c,u+1);return}const t=e[n];switch(c){case"date":e[n]=new Date(t);break;case"set":e[n]=new Set(t);break;case"map":e[n]=new Map(Object.entries(t));break;case"regexp":const l=/^\/(.*)\/([dgimsuy]*)$/.exec(t);if(l)e[n]=new RegExp(l[1],l[2]);else throw new Error(`Invalid regexp: ${t}`);break;case"bigint":e[n]=BigInt(t);break;case"undefined":e[n]=void 0;break;case"infinity":e[n]=Number.POSITIVE_INFINITY;break;case"-infinity":e[n]=Number.NEGATIVE_INFINITY;break;case"nan":e[n]=NaN;break;case"error":const f=new Error(t.message);f.name=t.name,f.stack=t.stack,e[n]=f;break;default:let $=b.get(c);$&&(e[n]=$.deserialize(t))}}}function y(){const r=p();return a(r)}function a(r){if(!r)return r;if(r.$$obj)return r.$$meta?m(r.$$obj,r.$$meta):r.$$obj;if(r.$$meta){const o=r.$$meta;return delete r.$$meta,m(r,o)}return r}export{y as u};
